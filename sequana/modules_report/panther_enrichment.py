#
#  This file is part of Sequana software
#
#  Copyright (c) 2020 - Sequana Development Team
#
#  Distributed under the terms of the 3-clause BSD license.
#  The full license is in the LICENSE file, distributed with this software.
#
#  website: https://github.com/sequana/sequana
#  documentation: http://sequana.readthedocs.io
#
##############################################################################
"""Module to write enrichment report"""
import ast
import os
import sys

from sequana.lazy import pandas as pd
from sequana.lazy import pylab

from sequana.modules_report.base_module import SequanaBaseModule
from sequana.utils.datatables_js import DataTable
from sequana.enrichment.panther import PantherEnrichment

from easydev import Progress

import colorlog

logger = colorlog.getLogger(__name__)

from sequana.utils import config


class ModulePantherEnrichment(SequanaBaseModule):
    """Write HTML report of variant calling. This class takes a csv file
    generated by sequana_variant_filter.
    """

    def __init__(
        self,
        gene_lists,
        taxon,
        enrichment_params={
            "padj": 0.05,
            "log2_fc": 3,
            "max_entries": 3000,
            "nmax": 50,
            "mapper": None,
            "plot_compute_levels": False,
            "plot_logx": True,
        },
        command="",
        ontologies=["MF", "BP", "CC"]
    ):
        """.. rubric:: constructor"""
        super().__init__()
        self.title = "Panther Enrichment"

        self.command = command
        self.gene_lists = gene_lists
        self.enrichment_params = enrichment_params
        self.taxon = taxon
        self.nmax = enrichment_params.get("nmax", 50)


        # compute the enrichment here once for all, This may take time
        from sequana import logger
        logger.setLevel("INFO")

        logger.info("Computing enrichment. Takes time")
        self.pe = PantherEnrichment(
            self.gene_lists,
            self.taxon,
            max_entries=self.enrichment_params["max_entries"],
            log2_fc_threshold=self.enrichment_params["log2_fc"],
        )

        self.ontologies =ontologies

        # Compute the enrichment
        self.pe.compute_enrichment(ontologies=self.ontologies)
        self.df_stats = self.pe.get_mapping_stats()[['category', 'mapped_percentage', 'total']]


        self.create_report_content()
        self.create_html("enrichment.html")

    def create_report_content(self):
        self.sections = list()
        self.summary()
        self.add_go()
        self.sections.append(
            {"name": "3 - Info", "anchor": "command", "content": self.command}
        )

    def summary(self):
        """Add information."""

        total_up = len(self.gene_lists['up'])
        total_down = len(self.gene_lists['down'])
        total = total_up + total_down
        log2fc = self.enrichment_params["log2_fc"]

        # create html table for taxon information
        _taxon_id = self.pe.taxon_info["taxon_id"]
        _taxon_name = self.pe.taxon_info["long_name"]

        # table of undertermined IDs
        df_stats = self.df_stats.drop_duplicates()
        datatable = DataTable(df_stats, "unmapped")
        datatable.datatable.datatable_options = {
                "scrollX": "true",
                "pageLength": 10,
                "scrollCollapse": "true",
                "dom": "Bfrtip",
                "buttons": ["copy", "csv"],
        }
        js = datatable.create_javascript_function()
        html_table = datatable.create_datatable(float_format="%E")


        self.sections.append(
            {
                "name": "1 - Summary",
                "anchor": "filters_option",
                "content": f"""

<p>In the following sections, you will find the GO
terms enrichment. The input data for those analyis is the output of the RNADiff
analysis where adjusted p-values above 0.05 are excluded. Moreover, we removed 
candidates with log2 fold change below {log2fc}. Using these filters, the list of
differentially expressed genes is made of {total_up} up and {total_down} down genes (total {total})</p>
<p> In the following plots you can find the first GO terms that are enriched, keeping a 
maximum of {self.nmax} identifiers. </p>

<p>The taxon used is {_taxon_name} (ID {_taxon_id}).<br>

<p> Check the following table for the percentage of mapped genes on Panther
DB</p>


{js}{html_table}
""",
            }
        )

    def add_go(self):
        # somehow, logger used here and in add_kegg must be global. If you call
        # add_go and then add_kegg, logger becomes an unbound local variable.
        # https://stackoverflow.com/questions/10851906/python-3-unboundlocalerror-local-variable-referenced-before-assignment
        # global logger
        style = "width:85%"
        level = logger.level
        logger.setLevel(level)


        html_intro = """
<p>Here below is a set of plots showing the enriched GO terms using the down
regulated genes only, and then the up-regulated genes only. When possible a
graph of the found GO terms is provided. MF stands for molecular
function, CC for cellular components and BP for biological process.</p>
        </div>
        """.format(
            self.pe.summary["padj_threshold"],
            self.pe.summary["fold_change_range"][0],
            self.pe.summary["fold_change_range"][1],
            self.pe.summary["DGE_after_filtering"]["down"],
            self.pe.summary["DGE_after_filtering"]["up"],
        )



        # a utility function to create the proper html table
        def get_html_table(this_df, identifier):
            df = this_df.copy()

            links = []
            for x in df['id']:
                if x.startswith("PC"):
                    links.append(f"http://www.pantherdb.org/panther/category.do?categoryAcc={x}")
                elif x.startswith("R-"):
                    links.append(f"https://reactome.org/PathwayBrowser/#/{x}")
                else:
                    links.append(f"https://www.ebi.ac.uk/QuickGO/term/{x}")
            df["links"] = links
            for x in ["term", "fdr2", "abs_log2_fold_enrichment", "pct_diff_expr"]:
                try:
                    del df[x]
                except:
                    pass

            first_col = df.pop("id")
            df.insert(0, "id", first_col)
            df = df.sort_values(by="fold_enrichment", ascending=False)

            datatable = DataTable(pd.DataFrame(df), identifier)
            datatable.datatable.set_links_to_column("links", "id")
            datatable.datatable.datatable_options = {
                "scrollX": "true",
                "pageLength": 10,
                "scrollCollapse": "true",
                "dom": "Bfrtip",
                "buttons": ["copy", "csv"],
            }
            js = datatable.create_javascript_function()
            html_table = datatable.create_datatable(float_format="%E")
            return js + html_table


        # =====================================================================================
        # DOWN CASES
        # =====================================================================================
        self._temp_df = {}
        self._minus = {}
        self._plus = {}

        html_down = ""
        for ontology in self.ontologies:
            df = self.pe.plot_go_terms("down", ontologies=ontology, compute_levels=False)

            def plot_go_terms_down(filename, ontology, df):
                df = self.pe.plot_go_terms(
                    "down",
                    ontologies=ontology,
                    compute_levels=self.enrichment_params["plot_compute_levels"],
                    log=self.enrichment_params["plot_logx"],
                )
                self._temp_df[ontology] = df.copy()
                self._plus[ontology] = sum(df.plus_minus == "+")
                self._minus[ontology] = sum(df.plus_minus == "-")
                pylab.savefig(f"{config.output_dir}/Panther_down_{ontology}.png")
                pylab.savefig(filename)
                pylab.close()

            if len(df):
                image = self.create_embedded_png(
                    plot_go_terms_down,
                    "filename",
                    style=style,
                    ontology=ontology,
                    df=df,
                )

                html_down += f"<h4>Down - {ontology}</h4><p>For {ontology}, we found {self._plus[ontology]+self._minus[ontology]} go terms. Showing {self.nmax} here below (at most). The full list is downlodable from the CSV file hereafter.</p> {image} <br>"
                html_down += get_html_table(
                    self._temp_df[ontology], f"GO_table_down_{ontology}"
                )
            else:
                html_down += f"<h4>Down - {ontology}</h4><p>For {ontology} ({ontology}), we found 0 enriched go terms. </p><br>"

        filenames = []
        for ontology in self.ontologies:
            if "PROTEIN" in ontology or "PATHWAY" in ontology:
                continue
            filename = f"{config.output_dir}/Chart_down_{ontology}.png"
            if ontology in self._temp_df and len(self._temp_df[ontology]):
                logger.info(f"Saving chart for case {ontology} (down) in {filename}")
                self.pe.save_chart(self._temp_df[ontology], filename)
                filenames.append(f"Chart_down_{ontology}.png")
        fotorama_down = "<h4>Charts down</h2>" + self.add_fotorama(filenames)

        # =====================================================================================
        # UP CASES
        # =====================================================================================
        self._temp_df = {}
        self._minus = {}
        self._plus = {}
        html_up = ""


        for ontology in self.ontologies:

            df = self.pe.plot_go_terms(
                "up",
                ontologies=ontology,
                compute_levels=self.enrichment_params["plot_compute_levels"],
                log=self.enrichment_params["plot_logx"],
            )

            def plot_go_terms_up(filename, ontology, df):
                self._temp_df[ontology] = df.copy()
                self._plus[ontology] = sum(df.plus_minus == "+")
                self._minus[ontology] = sum(df.plus_minus == "-")
                pylab.savefig(f"{config.output_dir}/Panther_up_{ontology}.png")
                pylab.savefig(filename)
                pylab.close()

            if len(df):
                image = self.create_embedded_png(
                    plot_go_terms_up,
                    "filename",
                    style=style,
                    ontology=ontology,
                    df=df,
                )

                N = self._plus[ontology] + self._minus[ontology]
                html_up += f"<h4>Up - {ontology}</h4><p>For {ontology}, we found {N} go terms. Showing {self.nmax} here below (at most). The full list is downlodable from the CSV file hereafter.</p>"
                html_up += image + " <br>"
                html_up += get_html_table(
                    self._temp_df[ontology], f"GO_table_up_{ontology}"
                )
            else:
                html_up += "<h4>Up - {ontology}</h4><p>For {ontology} ({case}), we found 0 enriched go terms. </p>"

        filenames = []
        for ontology in self.ontologies:
            if "PROTEIN" in ontology or "PATHWAY" in ontology:
                continue
            filename = f"{config.output_dir}/Chart_up_{ontology}.png"
            if ontology in self._temp_df and len(self._temp_df[ontology]):
                logger.info(f"Saving chart for case {ontology} (up) in {filename}")
                self.pe.save_chart(self._temp_df[ontology], filename)
                filenames.append(f"Chart_up_{ontology}.png")
        fotorama_up = "<h4>Charts up</h2>" + self.add_fotorama(filenames)

        html = f"{html_intro} {html_down} <hr> {fotorama_down}<hr> {html_up} <hr> {fotorama_up}<hr>"
        self.sections.append({"name": "2 - GO", "anchor": "go", "content": html})

